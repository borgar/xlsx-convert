{"version":3,"sources":["../src/index.ts","../src/utils/convertStyles.ts","../src/ConversionContext.ts","../src/handler/rels.ts","../src/utils/attr.ts","../src/constants.ts","../src/handler/workbook.ts","../src/utils/normalizeFormula.ts","../src/utils/typecast.ts","../src/handler/sharedstrings.ts","../src/handler/persons.ts","../src/handler/theme.ts","../src/color.ts","../src/handler/styles.ts","../src/handler/rdstuct.ts","../src/handler/rdvalue.ts","../src/handler/metadata.ts","../src/handler/comments.ts","../src/handler/worksheet.ts","../src/utils/rle.ts","../src/handler/cell.ts","../src/utils/unescape.ts","../src/RelativeFormula.ts","../src/handler/external.ts","../src/handler/table.ts"],"sourcesContent":["import * as fs from 'fs/promises';\nimport path from 'path';\nimport JSZip from 'jszip';\nimport { Document, parseXML } from '@borgar/simple-xml';\n\nimport { convertStyles } from './utils/convertStyles.ts';\nimport { ConversionContext } from './ConversionContext.ts';\n\nimport { handlerRels, type Rel } from './handler/rels.ts';\nimport { handlerWorkbook } from './handler/workbook.ts';\nimport { handlerSharedStrings } from './handler/sharedstrings.ts';\nimport { handlerPersons } from './handler/persons.ts';\nimport { handlerTheme } from './handler/theme.ts';\nimport { handlerStyles } from './handler/styles.ts';\nimport { handlerRDStruct } from './handler/rdstuct.ts';\nimport { handlerRDValue } from './handler/rdvalue.ts';\nimport { handlerMetaData } from './handler/metadata.ts';\nimport { handlerComments } from './handler/comments.ts';\nimport { handlerWorksheet } from './handler/worksheet.ts';\nimport { handlerExternal } from './handler/external.ts';\nimport { handlerTable } from './handler/table.ts';\nimport type { JSFWorkbook } from './jsf-types.js';\n\nexport type * from './jsf-types.js';\n\n/** Convertion options */\nexport type ConversionOptions = {\n  skipMerged?: boolean;\n  cellFormulas?: boolean;\n};\n\nconst DEFAULT_OPTIONS: ConversionOptions = {\n  // skip cells that are a part of merges\n  skipMerged: true,\n  // formulas are attached to cells rather than being included separately\n  cellFormulas: false,\n};\n\n/**\n * Convert an XLSX file into a JSON format.\n *\n * @param filename Target file to convert\n * @param options Conversion options\n * @param [options.skipMerged] Skip any cells that are a part of merges.\n * @param [options.cellFormulas] Formulas are attached to cells rather than being included separately.\n * @return A JSON spreadsheet object.\n */\nexport default async function convert (\n  filename: string,\n  options: ConversionOptions = DEFAULT_OPTIONS,\n): Promise<JSFWorkbook> {\n  return convertBinary(await fs.readFile(filename), filename, options);\n}\n\n/**\n * Convert an XLSX file into a JSON format.\n *\n * @param buffer Buffer containing the file to convert\n * @param filename Name of the file being converted\n * @param [options] Conversion options\n * @return A JSON spreadsheet formatted object.\n */\nexport async function convertBinary (\n  buffer: Buffer | ArrayBuffer,\n  filename: string,\n  options: ConversionOptions = DEFAULT_OPTIONS,\n): Promise<JSFWorkbook> {\n  if (!(buffer instanceof ArrayBuffer || buffer instanceof Buffer)) {\n    throw new Error('Input is not a valid binary');\n  }\n  const zip = new JSZip();\n  const fdesc = await zip.loadAsync(buffer);\n\n  const getFile = async (f: string) => {\n    const fd = fdesc.file(f);\n    return fd\n      ? parseXML(await fd.async('string'))\n      : null;\n  };\n\n  const getRels = async (f = '') => {\n    const fDir = path.dirname(f);\n    const fBfn = path.basename(f);\n    const relsPath = path.join(fDir, '_rels', `${fBfn}.rels`);\n    return handlerRels(await getFile(relsPath), f);\n  };\n\n  async function maybeRead<T extends (dom: Document, context: ConversionContext) => any> (\n    context: ConversionContext,\n    type: string,\n    handler: T,\n    fallback: any = null,\n    rels: Rel[] | null = null,\n  ): Promise<ReturnType<T>> {\n    const rel = (rels || context.rels)\n      .find(d => d.type === type);\n    if (rel) {\n      return handler(await getFile(rel.target), context);\n    }\n    return fallback;\n  }\n\n  // manifest\n  const baseRels = await getRels();\n  const wbRel = baseRels.find(d => d.type === 'officeDocument');\n\n  const context = new ConversionContext();\n  context.rels = await getRels(wbRel.target);\n  context.options = Object.assign({}, DEFAULT_OPTIONS, options);\n  context.filename = path.basename(filename);\n\n  // external links\n  for (const rel of context.rels) {\n    if (rel.type === 'externalLink') {\n      const extRels = await getRels(rel.target);\n      const fileName = extRels.find(d => d.id === 'rId1').target;\n      const exlink = handlerExternal(await getFile(rel.target), fileName);\n      context.externalLinks.push(exlink);\n    }\n  }\n\n  // workbook\n  const wb = handlerWorkbook(await getFile(wbRel.target), context);\n  context.workbook = wb;\n  // copy external links in\n  if (context.externalLinks.length) {\n    wb.externals = context.externalLinks;\n  }\n\n  // strings\n  context.sst = await maybeRead(context, 'sharedStrings', handlerSharedStrings, []);\n\n  // persons\n  context.persons = await maybeRead(context, 'person', handlerPersons);\n\n  // richData\n  context.richStruct = await maybeRead(context, 'rdRichValueStructure', handlerRDStruct);\n  context.richValues = await maybeRead(context, 'rdRichValue', handlerRDValue);\n  // metadata\n  context.metadata = await maybeRead(context, 'sheetMetadata', handlerMetaData);\n\n  // theme / styles\n  context.theme = await maybeRead(context, 'theme', handlerTheme);\n  const styleDefs = await maybeRead(context, 'styles', handlerStyles);\n  wb.styles = convertStyles(styleDefs);\n\n  // worksheets\n  await Promise.all(context.sheetLinks.map(async (sheetLink, index) => {\n    const sheetRel = context.rels.find(d => d.id === sheetLink.rId);\n    if (sheetRel) {\n      const sheetName = sheetLink.name || `Sheet${sheetLink.index}`;\n      const sheetRels = await getRels(sheetRel.target);\n\n      // Note: This supports only threaded comments, not old-style comments\n      context.comments = await maybeRead(\n        context, 'threadedComment', handlerComments, {}, sheetRels,\n      );\n\n      // tables are accessed when external refs are normalized, so they have\n      // to be read them before that happens\n      const tableRels = sheetRels.filter(rel => rel.type === 'table');\n      for (const tableRel of tableRels) {\n        const tableDom = await getFile(tableRel.target);\n        const table = handlerTable(tableDom, context);\n        if (table) {\n          table.sheet = sheetName;\n          wb.tables.push(table);\n        }\n      }\n\n      // convert the sheet\n      const sh = handlerWorksheet(await getFile(sheetRel.target), context, sheetRels);\n      sh.name = sheetName;\n      wb.sheets[index] = sh;\n    }\n    else {\n      throw new Error('No rel found for sheet ' + sheetLink.rId);\n    }\n  }));\n\n  if (!options.cellFormulas) {\n    wb.formulas = context._formulasR1C1;\n  }\n\n  return wb;\n}\n","import type { StyleDefs } from '../handler/styles.ts';\nimport type { JSFStyle } from '../jsf-types.js';\n\nconst addStyle = (obj: JSFStyle, key: string, val: any, skip: any = null): number => {\n  if (val == null) {\n    return 0;\n  }\n  if (val.hsl) {\n    val = String(val);\n  }\n  if (skip === val) {\n    return 0;\n  }\n  obj[key] = val;\n  return 1;\n};\n\nfunction convertStyle (styleDefs: StyleDefs, styleIndex: number): JSFStyle {\n  const style = styleDefs.cellXf[styleIndex];\n  const s: JSFStyle = {};\n\n  if (style.numFmtId) {\n    const numFmt = styleDefs.numFmts[style.numFmtId];\n    if (typeof numFmt === 'string' && numFmt.toLowerCase() !== 'general') {\n      s.numberFormat = numFmt;\n    }\n  }\n\n  addStyle(s, 'horizontalAlignment', style.hAlign);\n  addStyle(s, 'verticalAlignment', style.vAlign, 'bottom');\n  addStyle(s, 'wrapText', !!style.wrapText, false);\n  addStyle(s, 'shrinkToFit', !!style.shrinkToFit, false);\n\n  if (style.font) {\n    const font = style.font;\n    addStyle(s, 'fontName', font.name, 'Calibri');\n    addStyle(s, 'fontSize', font.size, 11);\n    addStyle(s, 'fontColor', font.color, '#000');\n    addStyle(s, 'underline', font.underline);\n    addStyle(s, 'bold', font.bold, false);\n    addStyle(s, 'italic', font.italic, false);\n  }\n\n  if (style.fill?.fg) {\n    addStyle(s, 'fillColor', style.fill.fg, '#0000');\n  }\n\n  if (style.border) {\n    const { top, bottom, left, right } = style.border;\n    addStyle(s, 'borderTopStyle', top?.style);\n    addStyle(s, 'borderTopColor', top?.color, '#000');\n    addStyle(s, 'borderBottomStyle', bottom?.style);\n    addStyle(s, 'borderBottomColor', bottom?.color, '#000');\n    addStyle(s, 'borderLeftStyle', left?.style);\n    addStyle(s, 'borderLeftColor', left?.color, '#000');\n    addStyle(s, 'borderRightStyle', right?.style);\n    addStyle(s, 'borderRightColor', right?.color, '#000');\n  }\n\n  return s;\n}\n\nexport function convertStyles (styleDefs: StyleDefs): JSFStyle[] {\n  const styles = [];\n  for (let i = 0; i < styleDefs.cellXf.length; i++) {\n    styles[i] = convertStyle(styleDefs, i);\n  }\n  return styles;\n}\n","import type { Comment } from './handler/comments.ts';\nimport type { MetaData } from './handler/metadata.ts';\nimport type { RDStruct } from './handler/rdstuct.ts';\nimport type { RDValue } from './handler/rdvalue.ts';\nimport type { Rel } from './handler/rels.ts';\nimport type { Theme } from './handler/theme.ts';\nimport type { RelativeFormula } from './RelativeFormula.ts';\nimport type { JSFExternal, JSFWorkbook } from './jsf-types.js';\nimport type { ConversionOptions } from './index.ts';\n\ntype SheetLink = {\n  name: string;\n  rId: string;\n  index: number;\n};\n\nexport class ConversionContext {\n  workbook: JSFWorkbook | null;\n  sst: string[];\n  persons: Record<string, string>;\n  options: ConversionOptions;\n  rels: Rel[];\n  theme: Theme;\n  richStruct: RDStruct[];\n  richValues: RDValue[];\n  metadata: MetaData;\n  sheetLinks: SheetLink[];\n  comments: Record<string, Comment[]>;\n  externalLinks: JSFExternal[];\n  filename: string;\n  _formulasR1C1: string[];\n  _shared: Record<number, RelativeFormula>;\n  _merged: Record<string, string>;\n  _arrayFormula: string[];\n\n  constructor () {\n    this.rels = [];\n    this.options = {};\n    this.workbook = null;\n    this.sst = [];\n    this.persons = {};\n    this.theme = { scheme: [], indexedColors: [] };\n    this.richStruct = [];\n    this.richValues = null;\n    this.metadata = null;\n    this.sheetLinks = [];\n    this.comments = {};\n    this.externalLinks = [];\n    this.filename = '';\n    this._formulasR1C1 = [];\n    // shared formula\n    this._shared = {};\n    this._merged = {};\n    this._arrayFormula = [];\n  }\n}\n","import path from 'path';\nimport { attr } from '../utils/attr.ts';\nimport { REL_PREFIXES } from '../constants.ts';\nimport { Document } from '@borgar/simple-xml';\n\nexport type Rel = {\n  id: string;\n  type: string;\n  target: string;\n};\n\nexport function handlerRels (dom: Document, basepath = 'xl/workbook.xml'): Rel[] {\n  basepath = path.dirname(basepath);\n  const rels = [];\n  if (dom) {\n    dom\n      .querySelectorAll('Relationship')\n      .forEach(d => {\n        const mode = attr(d, 'TargetMode');\n        let type = attr(d, 'Type');\n        let target = attr(d, 'Target');\n        for (const p of REL_PREFIXES) {\n          if (type.startsWith(p)) {\n            type = type.slice(p.length);\n            if (mode !== 'External') {\n              target = path.join(basepath, target);\n            }\n            break;\n          }\n        }\n        rels.push({\n          id: attr(d, 'Id'),\n          type: type,\n          target: target,\n        });\n      });\n  }\n  return rels;\n}\n","import type { Element } from '@borgar/simple-xml';\n\nexport function attr (node: Element, name: string, fallBack: string = null): string | null {\n  if (node.hasAttribute(name)) {\n    return node.getAttribute(name);\n  }\n  return fallBack;\n}\n\nexport function numAttr (node: Element, name: string, fallBack: number = null): number | null {\n  const v = attr(node, name);\n  return v == null ? fallBack : +v;\n}\n\nexport function boolAttr (node: Element, name: string, fallBack: any = null): boolean | null {\n  const v = attr(node, name, fallBack);\n  return v == null ? fallBack : !!+v;\n}\n","/* eslint-disable @stylistic/array-element-newline */\n\nexport const REL_PREFIXES = [\n  // standard\n  'http://schemas.microsoft.com/office/2017/10/relationships/',\n  'http://schemas.microsoft.com/office/2017/06/relationships/',\n  'http://schemas.openxmlformats.org/officeDocument/2006/relationships/',\n  'http://schemas.openxmlformats.org/package/2006/relationships/',\n  // strict\n  'http://purl.oclc.org/ooxml/officeDocument/relationships/',\n];\n\n// switching to UK english has moved all $ to kr.\nexport const BUILTIN_FORMATS: Record<number, string> = {\n  0: 'General',\n  1: '0',\n  2: '0.00',\n  3: '#,##0',\n  4: '#,##0.00',\n  // These next four are locale dependent. For example the Icelandic locale uses `#,##0 \"kr.\";-#,##0 \"kr.\"`\n  5: '\"$\"#,##0_);(\"$\"#,##0)',\n  6: '\"$\"#,##0_);[Red](\"$\"#,##0)',\n  7: '\"$\"#,##0.00_);(\"$\"#,##0.00)',\n  8: '\"$\"#,##0.00_);[Red](\"$\"#,##0.00)',\n  9: '0%',\n  10: '0.00%',\n  11: '0.00E+00',\n  12: '# ?/?',\n  13: '# ??/??',\n  // Format 14, Excel's default \"Short Date\" is very locale dependent:\n  // It seem to use OS short date format: \"1/2/09\", \"2.1.1909\", \"02-01-1909\"\n  14: 'm/d/yy',\n  // Next three have locale dependent delimiter, and possibly more:\n  15: 'd-mmm-yy',\n  16: 'd-mmm',\n  17: 'mmm-yy',\n  18: 'h:mm AM/PM',\n  19: 'h:mm:ss AM/PM',\n  20: 'h:mm',\n  21: 'h:mm:ss',\n  37: '#,##0_);(#,##0)',\n  38: '#,##0_);[Red](#,##0)',\n  39: '#,##0.00_);(#,##0.00)',\n  40: '#,##0.00_);[Red](#,##0.00)',\n  41: '_(* #,##0_);_(* \\\\(#,##0\\\\);_(* \"-\"_);_(@_)',\n  42: '_(\"$\"* #,##0_);_(\"$\"* \\\\(#,##0\\\\);_(\"$\"* \"-\"_);_(@_)',\n  43: '_(* #,##0.00_);_(* \\\\(#,##0.00\\\\);_(* \"-\"??_);_(@_)',\n  44: '_(\"$\"* #,##0.00_);_(\"$\"* \\\\(#,##0.00\\\\);_(\"$\"* \"-\"??_);_(@_)',\n  45: 'mm:ss',\n  46: '[h]:mm:ss',\n  47: 'mm:ss.0',\n  48: '##0.0E+0',\n  49: '@',\n  55: 'yyyy/mm/dd',\n};\n\n// formats IDs that point to other IDs\n[ [ 22, 21 ], [ 23, 21 ], [ 24, 21 ], [ 25, 21 ], [ 26, 14 ],\n  [ 27, 37 ], [ 28, 38 ], [ 29, 39 ], [ 30, 40 ], [ 31, 41 ],\n  [ 32, 42 ], [ 33, 43 ], [ 34, 44 ], [ 35, 45 ], [ 36, 46 ] ]\n  .forEach(([ to, from ]) => {\n    BUILTIN_FORMATS[to] = BUILTIN_FORMATS[from];\n  });\n\n// Default Color Index as per 18.8.27 of ECMA Part 4\nexport const COLOR_INDEX = [\n  'FF000000', 'FFFFFFFF', 'FFFF0000', 'FF00FF00', 'FF0000FF', // 0-4\n  'FFFFFF00', 'FFFF00FF', 'FF00FFFF', 'FF000000', 'FFFFFFFF', // 5-9\n  'FFFF0000', 'FF00FF00', 'FF0000FF', 'FFFFFF00', 'FFFF00FF', // 10-14\n  'FF00FFFF', 'FF800000', 'FF008000', 'FF000080', 'FF808000', // 15-19\n  'FF800080', 'FF008080', 'FFC0C0C0', 'FF808080', 'FF9999FF', // 20-24\n  'FF993366', 'FFFFFFCC', 'FFCCFFFF', 'FF660066', 'FFFF8080', // 25-29\n  'FF0066CC', 'FFCCCCFF', 'FF000080', 'FFFF00FF', 'FFFFFF00', // 30-34\n  'FF00FFFF', 'FF800080', 'FF800000', 'FF008080', 'FF0000FF', // 35-39\n  'FF00CCFF', 'FFCCFFFF', 'FFCCFFCC', 'FFFFFF99', 'FF99CCFF', // 40-44\n  'FFFF99CC', 'FFCC99FF', 'FFFFCC99', 'FF3366FF', 'FF33CCCC', // 45-49\n  'FF99CC00', 'FFFFCC00', 'FFFF9900', 'FFFF6600', 'FF666699', // 50-54\n  'FF969696', 'FF003366', 'FF339966', 'FF003300', 'FF333300', // 55-59\n  'FF993300', 'FF993366', 'FF333399', 'FF333333', 'System Foreground', // 60-64\n  'System Background', // 65\n];\n\n// https://social.technet.microsoft.com/Forums/windows/en-US/ac76cc56-6ff2-4778-b260-8141d7170a3b/windows-7-highlight-text-color-or-selected-text-color-in-aero\nexport const NAMED_COLORS = {\n  // not sure why this is reversed?\n  'system foreground': 'FF000000',\n  'system background': 'FFFFFFFF',\n  // 'system foreground': 'FFFFFFFF',\n  // 'system background': 'FF000000',\n  'activeborder': 'FFB4B4B4',\n  'activetitle': 'FF99B4D1',\n  'appworkspace': 'FFABABAB',\n  'background': 'FF000000',\n  'buttonalternateface': 'FF000000',\n  'buttondkshadow': 'FF696969',\n  'buttonface': 'FFF0F0F0',\n  'buttonhilight': 'FFFFFFFF',\n  'buttonlight': 'FFE3E3E3',\n  'buttonshadow': 'FFA0A0A0',\n  'buttontext': 'FF000000',\n  'gradientactivetitle': 'FFB9D1EA',\n  'gradientinactivetitle': 'FFD7E4F2',\n  'graytext': 'FF6D6D6D',\n  'hilight': 'FF3399FF',\n  'hilighttext': 'FFFFFFFF',\n  'hottrackingcolor': 'FF0066CC',\n  'inactiveborder': 'FFF4F7FC',\n  'inactivetitle': 'FFBFCDDB',\n  'inactivetitletext': 'FF000000',\n  'infotext': 'FF000000',\n  'infowindow': 'FFFFFFE1',\n  'menu': 'FFF0F0F0',\n  'menubar': 'FFF0F0F0',\n  'menuhilight': 'FF3399FF',\n  'menutext': 'FF000000',\n  'scrollbar': 'FFC8C8C8',\n  'titletext': 'FF000000',\n  'window': 'FFFFFFFF',\n  'windowframe': 'FF646464',\n  'windowtext': 'FF000000',\n};\n","import { Document } from '@borgar/simple-xml';\nimport { ConversionContext } from '../ConversionContext.ts';\nimport { attr, numAttr } from '../utils/attr.ts';\nimport { normalizeFormula } from '../utils/normalizeFormula.ts';\nimport { toInt } from '../utils/typecast.ts';\nimport type { JSFNameDefinition, JSFWorkbook } from '../jsf-types.js';\n\nexport function handlerWorkbook (dom: Document, context: ConversionContext): JSFWorkbook {\n  const wb: JSFWorkbook = {\n    filename: context.filename,\n    sheets: [],\n    names: [],\n    // charts: [],\n    calculationProperties: {\n      iterate: false,\n      iterateCount: 100,\n      iterateDelta: 0.001,\n      epoch: 1900,\n    },\n    styles: [],\n    tables: [],\n    // externals: [],\n  };\n\n  dom.querySelectorAll('sheets > sheet')\n    .forEach(d => {\n      context.sheetLinks.push({\n        name: attr(d, 'name'),\n        index: numAttr(d, 'sheetId'),\n        rId: attr(d, 'r:id'),\n      });\n    });\n\n  dom.getElementsByTagName('definedName')\n    .forEach(d => {\n      const name: JSFNameDefinition = {\n        name: attr(d, 'name'),\n        value: normalizeFormula(d.textContent, context),\n      };\n      const localSheetId = attr(d, 'localSheetId');\n      if (localSheetId) {\n        name.scope = context.sheetLinks[+localSheetId].name;\n      }\n      wb.names.push(name);\n    });\n\n  const pr = dom.querySelectorAll('workbook > workbookPr')[0];\n  wb.calculationProperties.epoch = (pr && numAttr(pr, 'date1904')) ? 1904 : 1900;\n\n  const calcPr = dom.getElementsByTagName('calcPr')[0];\n  if (calcPr) {\n    const iterate = toInt(attr(calcPr, 'iterate'));\n    if (iterate && isFinite(iterate)) {\n      wb.calculationProperties = {\n        iterate: true,\n        iterateCount: toInt(numAttr(calcPr, 'iterateCount', 100)),\n        iterateDelta: numAttr(calcPr, 'iterateDelta', 0.001),\n        epoch: wb.calculationProperties.epoch,\n      };\n    }\n  }\n\n  return wb;\n}\n","import {\n  type ReferenceStruct,\n  isFunction, isReference, parseA1Ref, parseStructRef, stringifyA1Ref,\n  stringifyStructRef, tokenTypes, tokenize,\n  type ReferenceA1,\n} from '@borgar/fx';\nimport type { JSFExternal } from '../jsf-types.js';\n\ntype Ref = ReferenceStruct | ReferenceA1;\ntype RefContext = string[];\n\nfunction updateContext (ref: Ref, externalLinks: JSFExternal[]): RefContext {\n  const context: RefContext = [];\n  if (ref.workbookName && isFinite(+ref.workbookName)) {\n    const wbIndex = +ref.workbookName - 1;\n    if (externalLinks[wbIndex]) {\n      context.push(externalLinks[wbIndex].filename);\n    }\n  }\n  if (ref.sheetName) {\n    context.push(ref.sheetName);\n  }\n  return context;\n}\n\nexport function normalizeFormula (formula: string, wb): string {\n  const tokens = tokenize(formula.normalize(), { xlsx: true });\n  let normalized = '';\n  tokens.forEach(t => {\n    if (isFunction(t)) {\n      // remove certain namespaces from functions\n      normalized += t.value.replace(/^(?:_xlfn\\.|_xludf\\.|_xlws\\.)+/i, '');\n      return;\n    }\n    else if (isReference(t) && wb?.externalLinks) {\n      if (t.type === tokenTypes.REF_NAMED) {\n        t.value = t.value.replace(/^(?:_xlpm\\.)/ig, '');\n      }\n      // normalize external references\n      // xlsx reference syntax is different from Excel's runtime language syntax\n      // in that external references are braced indexes into a links list, using\n      // `[2]Sheet1!A1`, rather than including a name `[Workbook.xlsx]Sheet1!A1`\n      if (t.value.includes('[')) {\n        let newValue: string;\n        if (t.type === tokenTypes.REF_STRUCT) {\n          const ref = parseStructRef(t.value, { xlsx: true });\n          if (ref.table && wb.tables?.length) {\n            // TODO: omit the table prefix if current cell is within the table\n          }\n          ref.context = updateContext(ref, wb.externalLinks);\n          newValue = stringifyStructRef(ref);\n        }\n        else {\n          const ref = parseA1Ref(t.value, { xlsx: true });\n          ref.context = updateContext(ref, wb.externalLinks);\n          newValue = stringifyA1Ref(ref);\n        }\n        normalized += newValue;\n        return;\n      }\n    }\n    normalized += t.value;\n  });\n  return normalized;\n}\n","export function toInt (n: string | number | null): number {\n  return n == null ? null : Math.floor(+n);\n}\n\nexport function toNum (n: string | null): number {\n  if (n == null) { return null; }\n  if (/[.Ee]/.test(n)) {\n    return Number(n);\n  }\n  return toInt(n);\n}\n\n","import { Document } from '@borgar/simple-xml';\nimport { numAttr } from '../utils/attr.ts';\n\nexport function handlerSharedStrings (dom: Document): string[] {\n  const sst = dom.querySelectorAll('sst')[0];\n\n  const stringTable = sst.querySelectorAll('si').map(d => {\n    return d.querySelectorAll('t').map(d => d.textContent).join('');\n  });\n\n  const count = numAttr(sst, 'uniqueCount', 0);\n  if (count !== stringTable.length) {\n    console.warn('String table did not contain correct amount of entries.');\n    console.warn(`I got ${stringTable.length}, but expected ${count}`);\n  }\n\n  return stringTable;\n}\n","import { Document } from '@borgar/simple-xml';\nimport { attr } from '../utils/attr.ts';\n\nexport function handlerPersons (dom: Document): Record<string, string> {\n  const persons: Record<string, string> = {};\n\n  dom.querySelectorAll('personlist > person')\n    .forEach(person => {\n      persons[attr(person, 'id')] = attr(person, 'displayName');\n    });\n\n  return persons;\n}\n","import type { Document } from '@borgar/simple-xml';\nimport { attr } from '../utils/attr.ts';\nimport { COLOR_INDEX } from '../constants.ts';\n\nconst colorIndexes = {\n  lt1:       0, // Light 1\n  dk1:       1, // Dark 1\n  lt2:       2, // Light 2\n  dk2:       3, // Dark 2\n  accent1:   4, // Accent 1\n  accent2:   5, // Accent 2\n  accent3:   6, // Accent 3\n  accent4:   7, // Accent 4\n  accent5:   8, // Accent 5\n  accent6:   9, // Accent 6\n  hlink:    10, // Hyperlink\n  folHlink: 11, // Followed Hyperlink\n};\n\nexport type Theme = {\n  scheme: string[];\n  indexedColors: string[];\n};\n\nexport function handlerTheme (dom: Document): Theme {\n  const theme: Theme = {\n    // FIXME: what is the default windows Excel color scheme? (clue: not this)\n    scheme: [\n      'WindowText',\n      'Window',\n      'FF000000',\n      'FF000000',\n      'FF000000',\n      'FF000000',\n      'FF000000',\n      'FF000000',\n      'FF000000',\n      'FF000000',\n      'FF000000',\n      'FF000000',\n    ],\n    indexedColors: [ ...COLOR_INDEX ],\n  };\n\n  const elements = dom.querySelectorAll('theme > themeElements > clrScheme > *');\n\n  elements.forEach(d => {\n    let index = colorIndexes[d.tagName];\n    if (index == null) {\n      index = theme.scheme.length;\n    }\n    d.children.forEach(c => {\n      // One of: [ srgbClr, sysClr ]\n      // Other variants in VML:\n      //   [ scrgbClr, srgbClr, hslClr, sysClr, schemeClr, prstClr ]\n      // TODO: determine if alternate colors are able to turn up in clrScheme.\n      const val = attr(c, 'val');\n      if (c.tagName === 'sysClr') {\n        theme.scheme[index] = val;\n      }\n      if (c.tagName === 'srgbClr') {\n        // for some reason colors here are in the RRGGBB format, not ARGB\n        theme.scheme[index] = 'FF' + val;\n      }\n    });\n  });\n\n  return theme;\n}\n","import type { Element } from '@borgar/simple-xml';\nimport { rgb, hsl } from 'd3-color';\nimport { attr, numAttr } from './utils/attr.ts';\nimport { NAMED_COLORS } from './constants.ts';\nimport type { Theme } from './handler/theme.ts';\n\nfunction bound (c: number): number {\n  if (c < 0) { return 0; }\n  if (c > 255) { return 255; }\n  return ~~(c);\n}\n\nexport class Color {\n  type: null | string;\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n  src: string;\n  name: string;\n  tint: number;\n\n  constuctor () {\n    this.type = null;\n    this.r = 0;\n    this.g = 0;\n    this.b = 0;\n    this.a = 1;\n    this.src = '';\n    this.name = '';\n    this.tint = 0;\n  }\n\n  rgb () {\n    return rgb(this.r, this.g, this.b);\n  }\n\n  hsl () {\n    return hsl(this.rgb());\n  }\n\n  toJSON () {\n    return this.toString();\n  }\n\n  toRgba () {\n    return `rgba(${bound(this.r)},${bound(this.g)},${bound(this.b)},${this.a})`;\n  }\n\n  toString () {\n    if (!this.a) { // transparent\n      return '#0000';\n    }\n\n    let s = '' +\n      bound(this.r).toString(16).padStart(2, '0') +\n      bound(this.g).toString(16).padStart(2, '0') +\n      bound(this.b).toString(16).padStart(2, '0');\n\n    if (this.a !== 1) {\n      // skip alpha if color is opaque\n      s += bound(this.a * 255).toString(16).padStart(2, '0');\n    }\n\n    // condense color if possible\n    if (/^(.)\\1(.)\\2(.)\\3(?:(.)\\4)?$/.test(s)) {\n      s = s[0] + s[2] + s[4] + (s[6] || '');\n    }\n\n    return '#' + s.toUpperCase();\n  }\n}\n\n/**\n * @param {import(\"@borgar/simple-xml\").Element} node\n * @param {import('./handler/theme.js').Theme} theme\n */\nexport function readColor (node: Element, theme: Theme) {\n  if (!node) { return null; }\n\n  const color = new Color();\n\n  let argb: string = attr(node, 'rgb'); // ARGB\n  if (argb) {\n    color.type = 'rgb';\n    color.src = argb;\n  }\n\n  const indexed = attr(node, 'indexed');\n  if (indexed) {\n    color.type = 'index';\n    color.src = indexed;\n    argb = theme.indexedColors[+indexed];\n  }\n\n  // theme: A zero-based index into the <clrScheme> collection (§20.1.6.2),\n  //        referencing a particular <sysClr> or <srgbClr> value expressed\n  //        in the Theme part.\n  const _theme = attr(node, 'theme');\n  if (_theme && theme) {\n    color.type = 'theme';\n    color.src = _theme;\n    argb = theme.scheme[_theme];\n  }\n\n  argb = argb?.toLowerCase();\n  if (argb in NAMED_COLORS) {\n    color.name = argb;\n    argb = NAMED_COLORS[argb];\n  }\n\n  if (argb) {\n    color.a = parseInt(argb.slice(0, 2), 16) / 255;\n    color.r = parseInt(argb.slice(2, 4), 16);\n    color.g = parseInt(argb.slice(4, 6), 16);\n    color.b = parseInt(argb.slice(6, 8), 16);\n  }\n\n  const tint = numAttr(node, 'tint', 0);\n  // tint: If tint is supplied, then it is applied to the RGB value of the color\n  //       to determine the final color applied.\n  // The tint value is stored as a double from -1.0 ... 1.0, where -1.0 means\n  // 100% darken and 1.0 means 100% lighten. In loading the RGB value, it is\n  // converted to HLS where HLS values are (0..HLSMAX), where HLSMAX is\n  // currently 255.\n  if (tint) {\n    color.tint = tint;\n    const h = color.hsl();\n    if (tint < 0) { // darken\n      const Ɛ = 1 + tint;\n      h.l = Ɛ * h.l;\n    }\n    else { // lighten\n      const Ɛ = 1 - tint;\n      h.l = (Ɛ * h.l) + (1 - Ɛ);\n    }\n    const rgb = h.rgb();\n    color.r = rgb.r;\n    color.g = rgb.g;\n    color.b = rgb.b;\n  }\n\n  return color.type ? color : null;\n}\n","import type { Document, Element } from '@borgar/simple-xml';\nimport { type Color, readColor } from '../color.ts';\nimport { attr, boolAttr } from '../utils/attr.ts';\nimport { BUILTIN_FORMATS } from '../constants.ts';\nimport type { ConversionContext } from '../ConversionContext.ts';\nimport type { Theme } from './theme.ts';\n\nfunction valOfNode (node: Element, subNodeName: string, fallback: any = null): string | null {\n  const subNode = node.querySelectorAll(subNodeName)[0];\n  if (subNode) {\n    return attr(subNode, 'val', fallback);\n  }\n  return fallback;\n}\n\ntype BorderSide = 'left' | 'right' | 'top' | 'bottom';\ntype Border = { style: string, color: Color };\ntype Borders = Record<BorderSide, Border>;\ntype Fill = { type: string, fg: Color };\ntype Font = {\n  size?: number,\n  name: string,\n  underline?: string,\n  bold: boolean,\n  italic: boolean,\n  color: Color,\n};\n\nexport type StyleDefs = {\n  cellStyleXfs: Xf[];\n  cellXf: Xf[];\n  fill: Fill[];\n  font: Font[];\n  numFmts: Record<number, string>;\n  border: Borders[];\n};\n\ntype Xf = Partial<{\n  xfId: string;\n  numFmtId: number;\n  numFmt: string;\n  fillId: number;\n  fill: Fill;\n  fontId: number;\n  font: Font;\n  borderId: number;\n  border: Borders;\n  hAlign: string;\n  vAlign: string;\n  wrapText: boolean;\n  shrinkToFit: boolean;\n}>;\n\nfunction readXf (d: Element, styles: StyleDefs) {\n  const xf: Xf = {};\n\n  const xfId = attr(d, 'xfId'); // read from cellStyleXfs\n  if (xfId) { xf.xfId = xfId; }\n\n  const numFmtId = attr(d, 'numFmtId');\n  if (numFmtId) {\n    xf.numFmtId = +numFmtId;\n    xf.numFmt = styles.numFmts[+numFmtId];\n  }\n\n  const fillId = boolAttr(d, 'applyFill') ? attr(d, 'fillId') : null;\n  if (fillId) {\n    xf.fillId = +fillId;\n    xf.fill = styles.fill[+fillId];\n  }\n\n  const fontId = attr(d, 'fontId');\n  if (fontId != null) {\n    xf.fontId = +fontId;\n    xf.font = styles.font[+fontId];\n  }\n\n  const borderId = attr(d, 'borderId');\n  if (borderId) {\n    xf.borderId = +borderId;\n    xf.border = styles.border[+borderId];\n  }\n\n  const align = d.querySelectorAll('alignment')[0];\n  if (align) {\n    const hAlign = attr(align, 'horizontal');\n    const vAlign = attr(align, 'vertical');\n    const wrapText = attr(align, 'wrapText');\n    const shrinkToFit = attr(align, 'shrinkToFit');\n    if (hAlign) { xf.hAlign = hAlign; }\n    if (vAlign) { xf.vAlign = vAlign; }\n    if (wrapText) { xf.wrapText = !!+wrapText; }\n    if (shrinkToFit) { xf.shrinkToFit = !!+shrinkToFit; }\n  }\n\n  return xf;\n}\n\nfunction readBorder (node: Element, side: BorderSide | 'start' | 'end', theme: Theme) {\n  const b = node.querySelectorAll(side)[0];\n  if (b) {\n    const color = readColor(b.querySelectorAll('color')[0], theme);\n    const style = attr(b, 'style');\n    if (color || style) {\n      return { style: style, color: color };\n    }\n  }\n}\n\nfunction readFont (node: Element, theme: Theme): Font {\n  const u = node.querySelectorAll('u')[0];\n  const b = node.querySelectorAll('b')[0];\n  const i = node.querySelectorAll('i')[0];\n  let name = valOfNode(node, 'name');\n  if (name === 'Calibri (Body)') {\n    name = 'Calibri';\n  }\n  return {\n    size: +valOfNode(node, 'sz'),\n    name: name,\n    underline: u ? attr(u, 'val', 'single') : undefined,\n    bold: !!b,\n    italic: !!i,\n    color: readColor(node.querySelectorAll('color')[0], theme),\n  };\n}\n\nexport function handlerStyles (dom: Document, context: ConversionContext): StyleDefs {\n  const styles: StyleDefs = {\n    cellStyleXfs: [],\n    cellXf: [],\n    fill: [],\n    font: [],\n    numFmts: Object.assign({}, BUILTIN_FORMATS),\n    border: [],\n  };\n\n  // update indexed colors on the theme\n  dom.querySelectorAll('colors > indexedColors > rgbColor')\n    .forEach((node, i) => {\n      context.theme.indexedColors[i] = attr(node, 'rgb');\n    });\n\n  dom.querySelectorAll('numFmts > numFmt')\n    .forEach(node => {\n      styles.numFmts[attr(node, 'numFmtId')] = attr(node, 'formatCode');\n    });\n\n  dom.querySelectorAll('fonts > font')\n    .forEach(node => {\n      styles.font.push(readFont(node, context.theme));\n    });\n\n  dom.querySelectorAll('fills > fill > patternFill')\n    .forEach(fp => {\n      const type = fp && attr(fp, 'patternType');\n      const isSolid = type === 'solid';\n      styles.fill.push({\n        type: type,\n        fg: isSolid ? readColor(fp.querySelectorAll('fgColor')[0], context.theme) : null,\n        // bg: isSolid' ? readColor(child(fp, 'bgColor'), wb.theme) : null,\n      });\n    });\n\n  dom.querySelectorAll('borders > border')\n    .forEach(d => {\n      const borderDefs = {\n        left: readBorder(d, 'left', context.theme) || readBorder(d, 'start', context.theme),\n        right: readBorder(d, 'right', context.theme) || readBorder(d, 'end', context.theme),\n        top: readBorder(d, 'top', context.theme),\n        bottom: readBorder(d, 'bottom', context.theme),\n      };\n      styles.border.push(borderDefs);\n    });\n\n  // level 1 (named cell styles)\n  dom.querySelectorAll('cellStyleXfs > xf')\n    .forEach(d => styles.cellStyleXfs.push(readXf(d, styles)));\n  // level 2 (applied formatting)\n  dom.querySelectorAll('cellXfs > xf')\n    .forEach(d => {\n      const xf = readXf(d, styles);\n      const sxf: Xf = styles.cellStyleXfs[xf.xfId];\n      for (const key in sxf) {\n        if (xf[key] == null) {\n          xf[key] = sxf[key];\n        }\n      }\n      styles.cellXf.push(xf);\n    });\n\n  return styles;\n}\n","import { Document } from '@borgar/simple-xml';\nimport { attr } from '../utils/attr.ts';\n\nexport type RDStructKey = {\n  name: string;\n  type: string;\n};\n\nexport type RDStruct = {\n  type: string;\n  keys: RDStructKey[];\n};\n\nexport function handlerRDStruct (dom: Document): RDStruct[] {\n  const structures = [];\n\n  dom.querySelectorAll('rvStructures > s')\n    .forEach(s => {\n      structures.push({\n        type: attr(s, 't'),\n        keys: s.getElementsByTagName('k').map(k => ({\n          name: attr(k, 'n'),\n          type: attr(k, 't'),\n        })),\n      });\n    });\n\n  return structures;\n}\n","import { Document } from '@borgar/simple-xml';\nimport { numAttr } from '../utils/attr.ts';\nimport { ConversionContext } from '../ConversionContext.ts';\n\nexport type RDValue = Record<string, string | number>;\n\nexport function handlerRDValue (dom: Document, context: ConversionContext): RDValue[] {\n  const values = [];\n  const structures = context.richStruct || [];\n\n  dom.querySelectorAll('rvData > rv')\n    .forEach(rv => {\n      const nth = numAttr(rv, 's', 0);\n      const s = structures[nth];\n      const val: Record<string, string | number> = { _type: s.type };\n\n      rv.getElementsByTagName('v')\n        .forEach((k, i) => {\n          const def = s.keys[i];\n          let v: string | number = k.textContent;\n          // FIXME: what other types exist? (a spec on it does not)\n          if (def.type === 'i') {\n            v = Math.floor(+v);\n          }\n          val[def.name] = v;\n        });\n\n      values.push(val);\n    });\n\n  return values;\n}\n","import type { Document, Element } from '@borgar/simple-xml';\nimport type { ConversionContext } from '../ConversionContext.ts';\nimport { attr, numAttr } from '../utils/attr.ts';\n\ntype MetaTableValue = Record<string, number | string>;\n\ntype MetaTable = {\n  name: string;\n  values: MetaTableValue[];\n};\n\nexport type MetaData = {\n  cells: MetaTableValue[];\n  values: MetaTableValue[];\n};\n\nfunction parseBk (bk: Element, tables: MetaTable[]): MetaTableValue {\n  const rc = bk.getElementsByTagName('rc')[0];\n  const t = numAttr(rc, 't', 0);\n  const v = numAttr(rc, 'v', 0);\n  const r = tables[t - 1];\n  if (!r?.values[v]) {\n    throw new Error(`Can't reach meta-value ${t}/${v} in metadata.xml`);\n  }\n  return r.values[v];\n}\n\nexport function handlerMetaData (dom: Document, context: ConversionContext): MetaData {\n  const tables: MetaTable[] = [];\n\n  dom.getElementsByTagName('futureMetadata')\n    .forEach(fMD => {\n      const table: MetaTableValue[] = [];\n      const metaName = attr(fMD, 'name');\n      tables.push({ name: metaName, values: table });\n      fMD.querySelectorAll('bk ext')\n        .forEach(ext => {\n          if (metaName === 'XLDAPR') {\n            const dAP = ext.getElementsByTagName('dynamicArrayProperties')[0];\n            table.push({\n              _type: '_dynamicArray',\n              fCollapsed: numAttr(dAP, 'fCollapsed'),\n              fDynamic: numAttr(dAP, 'fDynamic'),\n            });\n          }\n          else if (metaName === 'XLRICHVALUE') {\n            const rvb = ext.getElementsByTagName('rvb')[0];\n            table.push(context.richValues[numAttr(rvb, 'i', 0)]);\n          }\n        });\n    });\n\n  // Cell metadata contains information about the cell itself.\n  const cells = dom.querySelectorAll('cellMetadata > bk')\n    .map(bk => parseBk(bk, tables));\n\n  // Value metadata is information about the value of a particular cell.\n  // Value metadata properties can be propagated along with the value as\n  // it is referenced in formulas.\n  const values = dom.querySelectorAll('valueMetadata > bk')\n    .map(bk => parseBk(bk, tables));\n\n  return {\n    values: values,\n    cells: cells,\n  };\n}\n","import { Document } from '@borgar/simple-xml';\nimport { attr } from '../utils/attr.ts';\nimport { ConversionContext } from '../ConversionContext.ts';\n\nexport type Comment = {\n  a: string;\n  d: string;\n  t: string;\n};\n\nexport function handlerComments (dom: Document, context: ConversionContext): Record<string, Comment[]> {\n  const persons = context.persons;\n  const comments: Record<string, Comment[]> = {};\n\n  dom.getElementsByTagName('threadedComment')\n    .forEach(d => {\n      const ref = attr(d, 'ref');\n      if (!comments[ref]) {\n        comments[ref] = [];\n      }\n      const personId = attr(d, 'personId');\n      // wb.persons\n      comments[ref].push({\n        // author\n        a: persons[personId] || '',\n        d: new Date(Date.parse(attr(d, 'dT'))).toISOString(),\n        // text\n        t: d.getElementsByTagName('text')[0].textContent,\n      });\n    });\n\n  // FIXME: while threads are discarded, comments should still be ordered\n\n  return comments;\n}\n","import { parseA1Ref, stringifyA1Ref } from '@borgar/fx';\nimport { attr, numAttr } from '../utils/attr.ts';\nimport { rle } from '../utils/rle.ts';\nimport { handlerCell } from './cell.ts';\nimport { Document } from '@borgar/simple-xml';\nimport { ConversionContext } from '../ConversionContext.ts';\nimport type { Rel } from './rels.ts';\nimport type { JSFWorksheet } from '../jsf-types.js';\n\nexport function handlerWorksheet (dom: Document, context: ConversionContext, rels: Rel[]): JSFWorksheet {\n  const sheet: JSFWorksheet = {\n    name: '',\n    cells: {},\n    columns: [],\n    rows: [],\n    merges: [],\n    defaults: {\n      colWidth: 10,\n      rowHeight: 16,\n    },\n    // drawings: [],\n    // showGridLines: true,\n    hidden: 0,\n  };\n\n  const sheetView = dom.querySelector('sheetViews > sheetView');\n  // zoomScale/zoomScaleNormal\n  if (attr(sheetView, 'showGridLines') === '0') {\n    sheet.showGridLines = false;\n  }\n\n  // read hyperlinks\n  const hyperLinks = new Map<string, string>();\n  dom.querySelectorAll('hyperlinks > hyperlink').forEach(d => {\n    const relId = attr(d, 'r:id');\n    const rel = rels.find(item => item.id === relId);\n    hyperLinks.set(attr(d, 'ref'), rel?.target);\n  });\n\n  // find default col/row sizes\n  const sheetFormatPr = dom.getElementsByTagName('sheetFormatPr')[0];\n  if (sheetFormatPr) {\n    sheet.defaults.colWidth = numAttr(sheetFormatPr, 'baseColWidth', sheet.defaults.colWidth);\n    sheet.defaults.rowHeight = numAttr(sheetFormatPr, 'defaultRowHeight', sheet.defaults.rowHeight);\n  }\n\n  // decode column widths\n  dom.getElementsByTagName('col').forEach(d => {\n    const min = numAttr(d, 'min', 0);\n    const max = numAttr(d, 'max', 100000); // FIXME: What is the actual max value?\n    const hidden = numAttr(d, 'hidden', 0);\n    const width = hidden ? 0 : numAttr(d, 'width');\n    sheet.columns.push({\n      start: min,\n      end: max,\n      size: width,\n    });\n  });\n\n  context._shared = {};\n  context._arrayFormula = [];\n  context._merged = {};\n\n  // list merged cells\n  dom.getElementsByTagName('mergeCell')\n    .forEach(d => {\n      const ref = attr(d, 'ref');\n      const { top, left, bottom, right } = parseA1Ref(ref).range;\n      const anchor = stringifyA1Ref({ range: { top, left } });\n      for (let c = left; c <= right; c++) {\n        for (let r = top; r <= bottom; r++) {\n          context._merged[stringifyA1Ref({ range: { top: r, left: c } })] = anchor;\n        }\n      }\n      sheet.merges.push(ref);\n    });\n\n  // keep a list of row heights\n  const row_heights: [ number, number ][] = [];\n\n  // parse cells\n  dom.querySelectorAll('row')\n    .forEach(row => {\n      // .r = Row index. Indicates to which row in the sheet this\n      //                 <row> definition corresponds.\n      const r = attr(row, 'r');\n\n      // .hidden = 1 if the row is hidden (.collapsed also exists)\n      // .ht = Row height measured in point size\n      const isHidden = numAttr(row, 'hidden');\n      if (isHidden) {\n        row_heights.push([ +r, 0 ]);\n      }\n      else {\n        const ht = attr(row, 'ht');\n        if (ht != null) {\n          row_heights.push([ +r, +ht ]);\n        }\n      }\n\n      // FIXME: rows have styles:\n      // .customFormat = 1 if the row style should be applied.\n      // .s = Style Index. Index to style record for the row\n      //                   (only applied if customFormat attribute is '1').\n\n      // cells\n      row.querySelectorAll('> c').forEach(d => {\n        const id = attr(d, 'r');\n        if (context.options.skipMerged) {\n          if (context._merged[id] && context._merged[id] !== id) {\n            // this cell is part of a merged range\n            return;\n          }\n        }\n        const c = handlerCell(d, context);\n        if (c) {\n          if (hyperLinks.has(id)) {\n            c.l = hyperLinks.get(id);\n          }\n          sheet.cells[id] = c;\n        }\n      });\n    });\n\n  // run-length encode the row heights\n  sheet.rows = rle(row_heights, sheet.defaults.rowHeight);\n\n  // add .F tags to array formula cells\n  context._arrayFormula\n    .forEach(arrayRef => {\n      const { top, left, bottom, right } = parseA1Ref(arrayRef).range;\n      for (let r = top; r <= bottom; r++) {\n        for (let c = left; c <= right; c++) {\n          const ref = stringifyA1Ref({ range: { top: r, left: c } });\n          if (sheet.cells[ref]) {\n            sheet.cells[ref].F = arrayRef;\n          }\n        }\n      }\n    });\n\n  delete context._shared;\n  delete context._arrayFormula;\n  delete context._merged;\n\n  return sheet;\n}\n","import type { JSFGridSize } from '../jsf-types.js';\n\ntype IndexHeightPair = [ number, number ];\n\nexport function rle (list: IndexHeightPair[], defaultValue: number): JSFGridSize[] {\n  let lastItem = [];\n  let current: JSFGridSize;\n  return list\n    .sort((a, b) => a[0] - b[0])\n    .reduce((newList: JSFGridSize[], item: IndexHeightPair) => {\n      const nextInSeq = lastItem[0] + 1 === item[0];\n      const sameSize = lastItem[1] === item[1];\n      if (nextInSeq && sameSize) {\n        current.end = item[0];\n      }\n      else {\n        current = {\n          start: item[0],\n          end: item[0],\n          size: item[1],\n        };\n        newList.push(current);\n      }\n      lastItem = item;\n      return newList;\n    }, [])\n    .filter(d => d.size !== defaultValue);\n}\n","import { dateToSerial, isDateFormat } from 'numfmt';\nimport { translateToR1C1 } from '@borgar/fx';\nimport { toInt, toNum } from '../utils/typecast.ts';\nimport { attr, numAttr } from '../utils/attr.ts';\nimport { unescape } from '../utils/unescape.ts';\nimport { RelativeFormula } from '../RelativeFormula.ts';\nimport { normalizeFormula } from '../utils/normalizeFormula.ts';\nimport { Element } from '@borgar/simple-xml';\nimport { ConversionContext } from '../ConversionContext.ts';\nimport type { JSFCell } from '../jsf-types.ts';\n\nconst relevantStyle = (obj: Record<string, any>): boolean => {\n  return !!(\n    // obj['number-format'] ||\n    obj.fillColor ||\n    obj.borderTopStyle ||\n    obj.borderLeftStyle ||\n    obj.borderBottomStyle ||\n    obj.borderRightStyle\n  );\n};\n\n// ECMA - 18.3.1.4 (Cell)\nexport function handlerCell (node: Element, context: ConversionContext): JSFCell {\n  const cell: JSFCell = {};\n\n  // FIXME: these props are scoped by the sheet but exist on the WB object\n  //        during processing and are wiped per-sheet\n  const sharedF = context._shared;\n  const comments = context.comments;\n  const arrayFormula = context._arrayFormula;\n\n  // .r = reference (cell address)\n  const address = attr(node, 'r');\n  // .t = data type: The possible values for this attribute are defined by the\n  //                 ST_CellType simple type (§18.18.11).\n  let valueType = attr(node, 't', 'n');\n\n  // .s = style index: The index of this cell's style.\n  //                   Style records are stored in the Styles Part.\n  const styleIndex = Math.trunc(numAttr(node, 's', 0));\n  if (styleIndex) {\n    cell.s = styleIndex;\n  }\n\n  const vNode = node.querySelectorAll('> v')[0];\n  let v = vNode ? vNode.textContent : null;\n\n  // .vm = value metadata index: The zero-based index of the value metadata\n  //                             record associated with this cell's value\n  const vm = numAttr(node, 'vm');\n  if (vm && context.metadata) {\n    const meta = context.metadata.values[vm - 1];\n    if (meta._type === '_error') {\n      valueType = 'e';\n      // TODO: some of these may have .subType, does is matter?\n      if (meta.errorType === 8) {\n        v = '#SPILL!';\n      }\n      else if (meta.errorType === 11) {\n        v = '#UNKNOWN!';\n      }\n      else if (meta.errorType === 12) {\n        v = '#FIELD!';\n      }\n      else if (meta.errorType === 13) {\n        v = '#CALC!';\n      }\n    }\n  }\n\n  if (comments[address]) {\n    cell.c = comments[address];\n  }\n\n  if (valueType === 'inlineStr') {\n    valueType = 'str';\n    v = node.querySelectorAll('is t').map(d => d.textContent).join('');\n  }\n  if (v || valueType === 'str') {\n    if (valueType === 's') {\n      cell.v = context.sst ? context.sst[toInt(v)] : '';\n    }\n    else if (valueType === 'str') {\n      valueType = 's';\n      cell.v = v || '';\n    }\n    else if (valueType === 'b') {\n      cell.v = !!toInt(v);\n    }\n    else if (valueType === 'e') {\n      // FIXME: ensure error is a known error!\n      cell.v = v;\n      cell.t = 'e';\n    }\n    else if (valueType === 'd') {\n      if (!/[T ]/i.test(v) && v.includes(':')) {\n        // this is time only so prefix with Excel epoch date\n        v = '1899-12-31T' + v;\n      }\n      cell.v = dateToSerial(new Date(Date.parse(v)));\n    }\n    else if (valueType === 'n') {\n      let val = toNum(v);\n      // adjust dates if the workbook uses 1904 data system\n      if (context.workbook?.calculationProperties?.epoch === 1904 && styleIndex) {\n        const z = context.workbook.styles[styleIndex]?.['number-format'];\n        if (z && isDateFormat(z)) {\n          val += 1462;\n        }\n      }\n      cell.v = val;\n    }\n    else {\n      throw new Error('Missing support for data type: ' + valueType);\n    }\n  }\n\n  // ECMA - 18.3.1.40 f (Formula)\n  const fNode = node.querySelectorAll('> f')[0];\n  if (fNode) {\n    // .t (Formula Type): [ array | dataTable | normal | shared ]\n    const formulaType = attr(fNode, 't', 'normal');\n    let f: string | null = null;\n    // array for array-formula\n    if (formulaType === 'array') {\n      // .ref (Range of Cells): Range of cells which the formula applies to.\n      //   Only required for shared formula, array formula or data table.\n      //   Only written on the master formula, not subsequent formulas belonging\n      //   to the same shared group, array, or data table.\n      //   The possible values for this attribute are defined by the\n      //   ST_Ref simple type (§18.18.62).\n      const cellsRange = attr(fNode, 'ref');\n      if (cellsRange && cellsRange !== address) {\n        cell.F = cellsRange;\n        arrayFormula.push(cellsRange);\n      }\n      f = fNode.textContent;\n    }\n    // shared for shared formula\n    else if (formulaType === 'shared') {\n      // .si (Shared Group Index) - Optional attribute to optimize load\n      //       performance by sharing formulas. the si attribute is used to\n      //       refer to the cell containing the formula. Two formulas are\n      //       considered to be the same when their respective representations\n      //       in R1C1-reference notation, are the same.\n      const shareGroupIndex = attr(fNode, 'si');\n      if (!sharedF[shareGroupIndex]) {\n        sharedF[shareGroupIndex] = new RelativeFormula(fNode.textContent, address);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      f = sharedF[shareGroupIndex].translate(address);\n    }\n    // dataTable for data table formula\n    else if (formulaType.toLowerCase() === 'datatable') {\n      // .dt2D (Data Table 2- D)\n      // .dtr (Data Table Row)\n      // .dtr (Data Table Row)\n      // .r2 (Input Cell 2)\n      // FIXME: support dataTable formula\n      // console.log('dataTable formula');\n    }\n    else {\n      f = fNode.textContent;\n    }\n\n    if (f) {\n      if (context.options.cellFormulas) {\n        cell.f = normalizeFormula(f, context);\n      }\n      else {\n        const rc = normalizeFormula(translateToR1C1(f, address) as string, context);\n        let fi = context._formulasR1C1.indexOf(rc);\n        if (fi < 0) {\n          fi = context._formulasR1C1.length;\n          context._formulasR1C1.push(rc);\n        }\n        cell.f = fi;\n      }\n    }\n  }\n\n  // unescape the strange OOXML character escaping\n  // (seems only used for <32 ASCII codes?)\n  if (typeof cell.v === 'string') {\n    cell.v = unescape(cell.v);\n  }\n\n  // don't emit the cell if it is empty\n  if (\n    cell.v == null &&\n    cell.f == null &&\n    (!cell.s || !relevantStyle(context.workbook.styles[styleIndex]))\n  ) {\n    return null;\n  }\n\n  return cell;\n}\n","export function unescape (str: string): string {\n  return str.replace(\n    /_x([\\da-f]{4})_/gi,\n    (m, n) => String.fromCharCode(parseInt(n, 16)),\n  );\n}\n","import { translateToA1, translateToR1C1 } from '@borgar/fx';\n\nexport class RelativeFormula {\n  anchorA1: string;\n  formula: string;\n  relative: string;\n\n  constructor (formula: string, anchorCell: string) {\n    this.anchorA1 = anchorCell;\n    this.formula = formula;\n    this.relative = translateToR1C1(formula, anchorCell) as string;\n  }\n\n  /** @param {string} offsetCell */\n  translate (offsetCell: string): string {\n    return translateToA1(this.relative, offsetCell) as string;\n  }\n}\n","import type { Document } from '@borgar/simple-xml';\nimport { attr, numAttr } from '../utils/attr.ts';\nimport { handlerCell } from './cell.ts';\nimport { normalizeFormula } from '../utils/normalizeFormula.ts';\nimport { ConversionContext } from '../ConversionContext.ts';\nimport type { JSFExternal } from '../jsf-types.js';\n\nexport function handlerExternal (dom: Document, fileName:string = ''): JSFExternal {\n  const external: JSFExternal = {\n    filename: fileName,\n    sheets: [],\n    names: [],\n  };\n\n  // read sheet names\n  dom.querySelectorAll('sheetNames > sheetName')\n    .forEach(sheetName => {\n      external.sheets.push({\n        name: attr(sheetName, 'val'),\n        cells: {},\n      });\n    });\n\n  // read cells and their values\n  const dummyContext = new ConversionContext();\n  dom.querySelectorAll('sheetDataSet > sheetData')\n    .forEach(sheetData => {\n      const sheetIndex = numAttr(sheetData, 'sheetId', 0);\n      const externalCells = external.sheets[sheetIndex].cells;\n      sheetData.querySelectorAll('row > cell')\n        .forEach(cell => {\n          const id = attr(cell, 'r');\n          const c = handlerCell(cell, dummyContext);\n          if (c) {\n            externalCells[id] = c;\n          }\n        });\n    });\n\n  // read defined names\n  dom.querySelectorAll('definedNames > definedName')\n    .forEach(definedName => {\n      external.names.push({\n        name: attr(definedName, 'name'),\n        value: normalizeFormula(attr(definedName, 'refersTo'), {}),\n      });\n    });\n\n  return external;\n}\n","import type { Document } from '@borgar/simple-xml';\nimport type { ConversionContext } from '../ConversionContext.ts';\nimport { attr, numAttr } from '../utils/attr.ts';\nimport { normalizeFormula } from '../utils/normalizeFormula.ts';\nimport type { JSFTable, JSFTableColumn } from '../jsf-types.js';\n\nexport function handlerTable (dom: Document, context: ConversionContext): JSFTable | void {\n  const tableElm = dom.getElementsByTagName('table')[0];\n  if (!tableElm) { return; }\n\n  const table: JSFTable = {\n    name: attr(tableElm, 'name'),\n    sheet: '',\n    ref: attr(tableElm, 'ref'),\n    headerRowCount: numAttr(tableElm, 'headerRowCount', 1),\n    totalsRowCount: numAttr(tableElm, 'totalsRowCount', 0), // totalsRowShown\n    columns: [],\n    // alt text: extLst>ext>table[altTextSummary]\n  };\n\n  // table has a sortState\n  // table has props for: row/col stripes, bold first/last column\n\n  tableElm\n    .querySelectorAll('tableColumns > tableColumn')\n    .forEach(node => {\n      const column: JSFTableColumn = {\n        name: attr(node, 'name'),\n        // totalsRowLabel: attr(node, 'totalsRowLabel'),\n      };\n\n      /*\n      { name: 'FOO',\n        total: { type: 'function', value: 'average' } ??\n        formula: 'XXX'\n      }\n      */\n      // what appears in the totals row can be:\n      // - a built in function:\n      //   `attr(node, 'totalsRowFunction')` => \"average\"\n      // - a custom formula:\n      //   `attr(node, 'totalsRowFunction') === 'custom'`\n      //   f = node.getElementsByTagName('totalsRowFormula').innerText\n      // - a label:\n      //   `attr(node, 'totalsRowLabel')` => \"Total\"\n\n      const f = node.getElementsByTagName('calculatedColumnFormula')[0];\n      if (f) {\n        column.formula = normalizeFormula(f.textContent, context);\n      }\n      table.columns.push(column);\n    });\n\n  return table;\n}\n"],"mappings":"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","names":["import_path","import_simple_xml","path","import_simple_xml","import_simple_xml","d","import_simple_xml","rgb","import_simple_xml","import_simple_xml","import_simple_xml","import_fx","import_fx","import_fx","import_simple_xml","import_simple_xml","JSZip","path","context"]}